// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import "openzeppelin/token/ERC20/ERC20.sol";
import "./ERC777TokensRecipient.sol";
import "./ERC777TokensSender.sol";
import "openzeppelin/utils/math/Math.sol";

/// @notice Bonding token with a linear bonding curve of price = total_supply
contract BondingTokenERC777 is
    ERC20,
    ERC777TokensRecipient,
    ERC777TokensSender
{
    /*//////////////////////////////////////////////////////////////
                                 STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Total eth reserve balance
    /// @dev This value will not necessarily equal the contract balance due to the possible for force sending eth to the contract
    uint256 public reserveBalance;

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Instantiates the contract with the name and symbol
    constructor() ERC20("BondingTokenERC777", "BT") {}

    /*//////////////////////////////////////////////////////////////
                               FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @notice Purchase tokens with eth
    /// @param to the address to mint the new tokens to
    /// @param maxEntryPrice the maximum price per token that the user is willing to begin purchasing tokens at
    /// @dev Note: that the maxEntryPrice is not the price that a user will get their tokens at, as the price will be pushed
    ///  up the bonding curve by the price impact of this transaction. This is simply the max price allowed before this purchase executes
    function purchase(address to, uint256 maxEntryPrice) external payable {
        uint256 _totalSupply = totalSupply();

        if (_totalSupply > maxEntryPrice) revert MaxSlippageExceeded();
        if (msg.value == 0) revert MustPayGreaterThanZero();

        reserveBalance += msg.value;

        uint256 newSupply = Math.sqrt(2 * reserveBalance);
        uint256 supplyChange = newSupply - _totalSupply;

        if (supplyChange == 0) revert PurchaseTooSmall();

        _mint(to, supplyChange);
    }

    /// @notice Sell tokens for eth
    /// @param to the address to send the eth to
    /// @param amount the amount of tokens to sell
    /// @param minExitPrice the minimum price per token that the user is willing to begin selling tokens at
    /// @dev Note: again, the sale price is not garuanteed to be better than minExitPrice, minExitPrice is the price
    /// that is acceptable for this user before the price impact of this sale is taken into account
    function sell(address to, uint256 amount, uint256 minExitPrice) public {
        _sell(msg.sender, to, amount, minExitPrice);
    }

    function _sell(
        address seller,
        address to,
        uint256 amount,
        uint256 minExitPrice
    ) internal {
        uint256 _totalSupply = totalSupply();

        if (_totalSupply < minExitPrice) revert MaxSlippageExceeded();
        if (amount == 0) revert MustSellGreaterThanZero();
        if (amount > balanceOf(seller)) revert InsufficientBalance();

        uint256 newTotalSupply = _totalSupply - amount;
        uint256 newReserveBalance = (newTotalSupply ** 2) / 2;
        uint256 changeInReserves = reserveBalance - newReserveBalance;

        _burn(seller, amount);
        reserveBalance = newReserveBalance;

        (bool success, ) = payable(address(to)).call{value: changeInReserves}(
            ""
        );

        if (!success) revert PayoutFailed();
    }

    /*//////////////////////////////////////////////////////////////
                                 ERC777
    //////////////////////////////////////////////////////////////*/

    function tokensToSend(
        address operator,
        address from,
        address to,
        uint amount,
        bytes memory userData,
        bytes memory operatorData
    ) external {}

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint amount,
        bytes memory userData,
        bytes memory operatorData
    ) external {}

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    /// @notice The user must specify a minExitPrice in data field
    error InvalidMinExitPriceData();

    /// @notice If no tokens are generated by the purchase, it will revert to save the buyer wasting their ether
    error PurchaseTooSmall();

    /// @notice The transaction will revert if the slippage exceeds the users maxEntryPrice or minExitPrice
    error MaxSlippageExceeded();

    /// @notice The transaction to payout ether failed
    error PayoutFailed();

    /// @notice You cannot purchase with zero ether
    error MustPayGreaterThanZero();

    /// @notice You cannot sell zero tokens
    error MustSellGreaterThanZero();

    /// @notice The user has insufficient tokens to execute the sale
    error InsufficientBalance();
}
